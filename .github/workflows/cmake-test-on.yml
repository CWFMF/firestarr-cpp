on:
  workflow_call:
    inputs:
      os:
        required: true
        type: string
      os_version:
        required: true
        type: string
      compiler:
        required: true
        type: string
      triplet:
        required: true
        type: string

jobs:
  cmake-test:
    name:  ${{ inputs.os }}-${{ inputs.os_version }}-${{ inputs.compiler }}-${{ matrix.variant }}
    runs-on: ${{ inputs.os }}-${{ inputs.os_version }}
    strategy:
      fail-fast: false
      matrix:
        variant: [Debug, Release]
    env:
      CXX: ${{ inputs.compiler }}
      VCPKG_DEFAULT_TRIPLET: ${{ inputs.triplet }}
      VCPKG_DISABLE_METRICS: true
      VCPKG_ROOT: ${{ github.workspace }}/vcpkg
      VCPKG_DEFAULT_BINARY_CACHE: ${{ github.workspace }}/vcpkg/.cache
      OUTPUT_BINARY: firestarr-${{ inputs.os }}-${{ inputs.target-cpu}}-${{ inputs.target-compiler }}-${{ matrix.variant }}

    steps:
    - uses: actions/checkout@v4
      with:
        submodules: true

    - uses: ilammy/msvc-dev-cmd@v1

    - uses: friendlyanon/setup-vcpkg@v1
      with:
        committish: 2025.12.12
        # getting a warning when cache exists, so just save/restore ourselves
        cache: false

    - uses: actions/cache@v4
      with:
        # vcpkg always builds release, so share cache between debug and release
        key: vcpkg-${{ inputs.os }}-${{ inputs.os_version }}-${{ inputs.compiler }}-${{ hashFiles('vcpkg.json', '.github/vcpkg_overlays/**') }}
        path: |
          ${{ env.VCPKG_DEFAULT_BINARY_CACHE }}

    - run: cmake --preset ${{ matrix.variant }}

    - name: Run cmake --build --parallel --preset ${{ matrix.variant }}
      run: |
        echo "::add-matcher::.github/cmake-problem-matcher.json"
        cmake --build --parallel --preset ${{ matrix.variant }}

    - run: ./firestarr -h

    - run: ctest --output-on-failure --preset ${{ matrix.variant }}

    - run: ./firestarr . 2024-06-03 58.81228184403946 -122.9117103995713 01:00 --ffmc 89.9 --dmc 59.5 --dc 450.9 --apcp_prev 0 -v --wx ./test/input/10N_50651/firestarr_10N_50651_wx.csv --output_date_offsets [1] --tz -5 --raster-root ./test/input/10N_50651/ --perim ./test/input/10N_50651/10N_50651.tif

    - name: Locate binary (macos)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'macos' }}
      id: locate-macos
      run: |
        # Find the built executable
        BINARY=$(find build -type f -name "firestarr" -perm +111 | head -1)
        if [ -z "$BINARY" ]; then
          echo "ERROR: Could not find firestarr binary"
          find build -type f -perm +111
          exit 1
        fi
        echo "binary=$BINARY" >> $GITHUB_OUTPUT
        echo "Found binary at: $BINARY"

    - name: Check binary dependencies (macos)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'macos' }}
      run: |
        echo "=== Binary info ==="
        file ${{ steps.locate-macos.outputs.binary }}
        echo ""
        echo "=== Dynamic dependencies ==="
        otool -L ${{ steps.locate-macos.outputs.binary }} || true

    - name: Package artifact (macos)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'macos' }}
      run: |
        mkdir -p dist
        cp ${{ steps.locate.outputs.binary }} dist/firestarr

        # Bundle data files if they exist
        [ -f firestarr/fuel.lut ] && cp firestarr/fuel.lut dist/
        [ -f firestarr/settings.ini ] && cp firestarr/settings.ini dist/
        [ -f firestarr/data/fuel.lut ] && cp firestarr/data/fuel.lut dist/
        [ -f firestarr/data/settings.ini ] && cp firestarr/data/settings.ini dist/

        # Create version info
        cd firestarr && git rev-parse HEAD > ../dist/VERSION && cd ..

        # List contents
        echo "=== Package contents ==="
        ls -la dist/

        # Create tarball
        tar -czvf ${{ env.OUTPUT_BINARY }}.tar.gz -C dist .

    - name: Upload artifact (macos)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'macos' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.OUTPUT_BINARY }}
        path: ${{ env.OUTPUT_BINARY }}.tar.gz
        retention-days: 30

    - name: Locate binary (linux)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'linux' }}
      id: locate-linux
      run: |
        # Find the built executable
        BINARY=$(find build -type f -name "firestarr" -executable | head -1)
        if [ -z "$BINARY" ]; then
          echo "ERROR: Could not find firestarr binary"
          find build -type f -executable
          exit 1
        fi
        echo "binary=$BINARY" >> $GITHUB_OUTPUT
        echo "Found binary at: $BINARY"

    - name: Check binary dependencies (linux)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'linux' }}
      run: |
        echo "=== Binary info ==="
        file ${{ steps.locate-linux.outputs.binary }}
        echo ""
        echo "=== Dynamic dependencies ==="
        ldd ${{ steps.locate-linux.outputs.binary }} || true

    - name: Package artifact (linux)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'linux' }}
      run: |
        mkdir -p dist
        cp ${{ steps.locate.outputs.binary }} dist/firestarr

        # Bundle data files if they exist
        [ -f firestarr/fuel.lut ] && cp firestarr/fuel.lut dist/
        [ -f firestarr/settings.ini ] && cp firestarr/settings.ini dist/
        [ -f firestarr/data/fuel.lut ] && cp firestarr/data/fuel.lut dist/
        [ -f firestarr/data/settings.ini ] && cp firestarr/data/settings.ini dist/

        # Create version info
        cd firestarr && git rev-parse HEAD > ../dist/VERSION && cd ..

        # List contents
        echo "=== Package contents ==="
        ls -la dist/

        # Create tarball
        tar -czvf ${{ env.OUTPUT_BINARY }}.tar.gz -C dist .

    - name: Upload artifact (linux)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'linux' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.OUTPUT_BINARY }}
        path: ${{ env.OUTPUT_BINARY }}.tar.gz
        retention-days: 30

    - name: Locate binary (windows)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'windows' }}
      id: locate-windows
      run: |
        $BINARY = Get-ChildItem -Path build -Recurse -Filter "firestarr.exe" | Select-Object -First 1 -ExpandProperty FullName
        if (-not $BINARY) {
          echo "ERROR: Could not find firestarr.exe"
          Get-ChildItem -Path build -Recurse -Filter "*.exe" | Select-Object FullName
          exit 1
        }
        echo "binary=$BINARY" >> $env:GITHUB_OUTPUT
        echo "Found binary at: $BINARY"
      shell: pwsh

    - name: Check binary dependencies (windows)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'windows' }}
      run: |
        echo "=== Binary info ==="
        Get-Item "${{ steps.locate-windows.outputs.binary }}" | Format-List Name, Length, LastWriteTime
        echo ""
        echo "=== Binary size ==="
        (Get-Item "${{ steps.locate-windows.outputs.binary }}").Length / 1MB | ForEach-Object { "{0:N2} MB" -f $_ }
      shell: pwsh

    - name: Package artifact (windows)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'windows' }}
      run: |
        New-Item -ItemType Directory -Force -Path dist

        Copy-Item "${{ steps.locate.outputs.binary }}" dist\firestarr.exe

        # Copy required DLLs from vcpkg
        $vcpkgBin = "C:\vcpkg\installed\x64-windows\bin"
        if (Test-Path $vcpkgBin) {
          Get-ChildItem "$vcpkgBin\*.dll" | Copy-Item -Destination dist\
        }

        # Bundle data files if they exist
        if (Test-Path firestarr\fuel.lut) { Copy-Item firestarr\fuel.lut dist\ }
        if (Test-Path firestarr\settings.ini) { Copy-Item firestarr\settings.ini dist\ }
        if (Test-Path firestarr\data\fuel.lut) { Copy-Item firestarr\data\fuel.lut dist\ }
        if (Test-Path firestarr\data\settings.ini) { Copy-Item firestarr\data\settings.ini dist\ }

        # Create version info
        cd firestarr
        git rev-parse HEAD | Out-File -FilePath ..\dist\VERSION -Encoding utf8
        cd ..

        # List contents
        echo "=== Package contents ==="
        Get-ChildItem dist

        # Create zip
        Compress-Archive -Path dist\* -DestinationPath ${{ env.OUTPUT_BINARY }}.zip
      shell: pwsh

    - name: Upload artifact (windows)
      if: ${{ matrix.variant == 'Release' && inputs.os == 'windows' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.OUTPUT_BINARY }}
        path: ${{ env.OUTPUT_BINARY }}.zip
        retention-days: 30
